{{define "content"}}
<div class="space-y-6">
  <div>
    <h1 class="text-xl font-bold">概览</h1>
    <div class="text-sm opacity-70">配置、规则、任务实时统计</div>
  </div>

  <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
    <div class="card bg-base-100 border border-base-200">
      <div class="card-body">
        <div class="card-title text-base">运行信息</div>
        <div class="text-sm"><span class="opacity-70">rclone 配置：</span><b>{{.RcloneConfigPathDisplay}}</b></div>
        <div class="text-sm"><span class="opacity-70">日志目录：</span><b>{{.LogDir}}</b></div>
      </div>
    </div>
    <div class="card bg-base-100 border border-base-200">
      <div class="card-body">
        <div class="card-title text-base">整体传输统计</div>
        <div class="text-sm"><span class="opacity-70">已传输总量：</span><b>{{humanBytes .TotalBytes}}</b></div>
        <div class="text-sm"><span class="opacity-70">当前总速度：</span><b>{{printf "%.1f" .TotalSpeed}} B/s</b></div>
        <div class="text-sm"><span class="opacity-70">运行中任务：</span><b>{{.RunningJobs}}</b></div>
      </div>
    </div>
  </div>

  <div class="card bg-base-100 border border-base-200">
    <div class="card-body">
      <div class="card-title text-base">实时曲线</div>
      <div class="flex flex-wrap gap-2 items-center">
        <select id="rtRule" class="select select-bordered select-sm w-full sm:w-56">
          <option value="">全局</option>
          {{range .Rules}}<option value="{{.Rule.ID}}">{{.Rule.ID}}</option>{{end}}
        </select>
        <select id="rtWindow" class="select select-bordered select-sm w-full sm:w-44">
          <option value="900">最近 15 分钟</option>
          <option value="3600" selected>最近 1 小时</option>
          <option value="21600">最近 6 小时</option>
          <option value="86400">最近 24 小时</option>
        </select>
        <div class="text-sm opacity-70">曲线不落库，仅在本页面打开后开始采样。</div>
      </div>

      <div id="rtEmpty" class="alert alert-info mt-3" style="display:none">
        <span>当前没有运行中的任务，实时曲线将保持空闲状态（当有任务运行时会自动开始绘制）。</span>
      </div>

      <div class="mt-4 space-y-4">
        <div>
          <div class="text-sm opacity-70 mb-2">总速度</div>
          <canvas id="rtSpeed" style="width:100%; height:220px; border:1px solid hsl(var(--b2)); border-radius:12px;"></canvas>
        </div>
        <div>
          <div class="text-sm opacity-70 mb-2">累计已传输</div>
          <canvas id="rtBytes" style="width:100%; height:220px; border:1px solid hsl(var(--b2)); border-radius:12px;"></canvas>
        </div>
      </div>
    </div>
  </div>

  <div class="card bg-base-100 border border-base-200">
    <div class="card-body">
      <div class="card-title text-base">同步规则</div>
      <div class="overflow-x-auto">
        <table class="table table-sm">
          <thead>
            <tr>
              <th>ID</th>
              <th>启用</th>
              <th>模式</th>
              <th>映射</th>
              <th>并发</th>
              <th>统计</th>
            </tr>
          </thead>
          <tbody>
            {{range .Rules}}
            <tr class="hover:bg-base-200/40">
              <td><a class="link" href="/rules/edit?id={{.Rule.ID}}">{{.Rule.ID}}</a></td>
              <td>{{if .Rule.Enabled}}是{{else}}否{{end}}</td>
              <td>{{.Rule.TransferMode}}</td>
              <td class="opacity-70">
                {{if eq .Rule.SrcKind "local"}}
                  local:{{.Rule.SrcLocalRoot}} → {{.Rule.DstRemote}}:{{.Rule.DstPath}}
                {{else}}
                  {{.Rule.SrcRemote}}:{{.Rule.SrcPath}} → {{.Rule.DstRemote}}:{{.Rule.DstPath}}
                {{end}}
              </td>
              <td class="opacity-70">{{.Rule.MaxParallelJobs}}</td>
              <td class="opacity-70">新={{.Counts.New}} 稳定={{.Counts.Stable}} 排队={{.Counts.Queued}} 传输中={{.Counts.Transferring}} 完成={{.Counts.Done}} 失败={{.Counts.Failed}}</td>
            </tr>
            {{end}}
          </tbody>
        </table>
      </div>
    </div>
  </div>

  <div class="card bg-base-100 border border-base-200">
    <div class="card-body">
      <div class="card-title text-base">最近任务</div>
      <div class="overflow-x-auto">
        <table class="table table-sm">
          <thead>
            <tr>
              <th>任务 ID</th>
              <th>规则</th>
              <th>模式</th>
              <th>状态</th>
              <th>开始时间</th>
              <th>已传输</th>
              <th>速度</th>
            </tr>
          </thead>
          <tbody>
            {{range .Jobs}}
            <tr class="hover:bg-base-200/40">
              <td><a class="link" href="/jobs/view?id={{.Job.JobID}}">{{.Job.JobID}}</a></td>
              <td>{{if hasPrefix .Job.RuleID "manual_"}}手动运行{{else}}{{.Job.RuleID}}{{end}}</td>
              <td>{{.Job.TransferMode}}</td>
              <td>
                <span class="badge {{if eq .Job.Status "running"}}badge-success{{else if eq .Job.Status "failed"}}badge-error{{else if eq .Job.Status "terminated"}}badge-warning{{else}}badge-info{{end}}">{{.Job.Status}}</span>
              </td>
              <td class="opacity-70">{{ts .Job.StartedAt}}</td>
              <td class="opacity-70">{{if .HasM}}{{humanBytes .Metric.Bytes}}{{else}}{{humanBytes .Job.BytesDone}}{{end}}</td>
              <td class="opacity-70">{{if .HasM}}{{printf "%.1f" .Metric.Speed}} B/s{{else}}{{printf "%.1f" .Job.AvgSpeed}} B/s{{end}}</td>
            </tr>
            {{end}}
          </tbody>
        </table>
      </div>

      <div class="mt-3 flex flex-wrap gap-2 items-center justify-between">
        <div class="text-sm opacity-70">共 {{.JobsTotal}} 条，页大小 {{.JobsPageSize}}，第 {{.JobsPage}} / {{.JobsTotalPages}} 页</div>
        <div class="flex flex-wrap gap-2 items-center">
          <form method="get" action="/" class="flex flex-wrap gap-2 items-center">
            <select name="jobs_page_size" class="select select-bordered select-sm" onchange="this.form.jobs_page.value='1'; this.form.submit();">
              <option value="10" {{if eq .JobsPageSize 10}}selected{{end}}>10 / 页</option>
              <option value="20" {{if eq .JobsPageSize 20}}selected{{end}}>20 / 页</option>
              <option value="50" {{if eq .JobsPageSize 50}}selected{{end}}>50 / 页</option>
              <option value="100" {{if eq .JobsPageSize 100}}selected{{end}}>100 / 页</option>
            </select>
            <input type="number" min="1" max="{{.JobsTotalPages}}" name="jobs_page" value="{{.JobsPage}}" class="input input-bordered input-sm w-28" placeholder="跳转页码">
            <button class="btn btn-sm" type="submit">跳转</button>
          </form>
          {{if .JobsHasPrev}}
            <a class="btn btn-ghost btn-sm" href="{{.JobsPrevURL}}">上一页</a>
          {{else}}
            <button class="btn btn-ghost btn-sm" disabled>上一页</button>
          {{end}}
          {{if .JobsHasNext}}
            <a class="btn btn-ghost btn-sm" href="{{.JobsNextURL}}">下一页</a>
          {{else}}
            <button class="btn btn-ghost btn-sm" disabled>下一页</button>
          {{end}}
          <a class="btn btn-sm btn-info text-info-content" href="/jobs">打开任务列表</a>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="/static/realtime_chart.js"></script>
<script>
  // Fallback: if static script failed to load, define chart helper inline.
  if (typeof createLineChart !== "function") {
    function createLineChart(canvas, opts) {
      const options = opts || {};
      const padding = options.padding || 36;
      const color = options.color || "#16baaa";
      const grid = options.grid || "rgba(0,0,0,0.08)";
      const text = options.text || "rgba(0,0,0,0.55)";
      const bg = options.bg || "#ffffff";
      const ctx = canvas.getContext("2d");
      function draw(points, formatter) {
        const w = canvas.width;
        const h = canvas.height;
        ctx.clearRect(0, 0, w, h);
        ctx.fillStyle = bg;
        ctx.fillRect(0, 0, w, h);
        if (!points || points.length < 2) {
          ctx.fillStyle = text;
          ctx.font = "12px sans-serif";
          ctx.fillText("暂无数据", padding, padding);
          return;
        }
        let minY = Infinity, maxY = -Infinity;
        for (const p of points) { if (p.y < minY) minY = p.y; if (p.y > maxY) maxY = p.y; }
        if (!isFinite(minY) || !isFinite(maxY)) return;
        if (minY === maxY) { maxY = minY + 1; }
        const minX = points[0].x;
        const maxX = points[points.length - 1].x;
        const plotW = w - padding * 2;
        const plotH = h - padding * 2;
        const xToPx = (x) => padding + (x - minX) * plotW / Math.max(1, (maxX - minX));
        const yToPx = (y) => padding + (maxY - y) * plotH / Math.max(1e-9, (maxY - minY));
        ctx.strokeStyle = grid;
        ctx.lineWidth = 1;
        ctx.beginPath();
        for (let i = 0; i <= 4; i++) {
          const y = padding + i * (plotH / 4);
          ctx.moveTo(padding, y);
          ctx.lineTo(w - padding, y);
        }
        ctx.stroke();
        ctx.fillStyle = text;
        ctx.font = "12px sans-serif";
        const fmt = formatter || ((v) => String(v));
        ctx.fillText(fmt(maxY), 6, padding + 4);
        ctx.fillText(fmt(minY), 6, h - padding + 4);
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(xToPx(points[0].x), yToPx(points[0].y));
        for (let i = 1; i < points.length; i++) ctx.lineTo(xToPx(points[i].x), yToPx(points[i].y));
        ctx.stroke();
        const last = points[points.length - 1];
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.arc(xToPx(last.x), yToPx(last.y), 3, 0, Math.PI * 2);
        ctx.fill();
      }
      return { draw };
    }
  }

  function initRealtimeCharts() {
    const intervalMs = 2000;
    const rtRule = document.getElementById("rtRule");
    const rtWindow = document.getElementById("rtWindow");
    const speedCanvas = document.getElementById("rtSpeed");
    const bytesCanvas = document.getElementById("rtBytes");
    const emptyBox = document.getElementById("rtEmpty");
    if (!rtRule || !rtWindow || !speedCanvas || !bytesCanvas) return;

    const speedChart = createLineChart(speedCanvas, { color: "#16baaa" });
    const bytesChart = createLineChart(bytesCanvas, { color: "#1e9fff" });
    let pointsSpeed = [];
    let pointsBytes = [];
    let errorStreak = 0;

    function canvasFit(canvas) {
      const dpr = window.devicePixelRatio || 1;
      const rect = canvas.getBoundingClientRect();
      const w = Math.max(200, Math.floor(rect.width * dpr));
      const h = Math.max(160, Math.floor(rect.height * dpr));
      if (canvas.width !== w) canvas.width = w;
      if (canvas.height !== h) canvas.height = h;
    }

    function humanBytes(n) {
      const u = 1024;
      if (n < u) return n + " B";
      const units = ["KiB","MiB","GiB","TiB","PiB"];
      let i = -1;
      let v = n;
      while (v >= u && i < units.length - 1) { v /= u; i++; }
      return v.toFixed(1) + " " + units[i];
    }
    function humanSpeed(n) { return humanBytes(n) + "/s"; }

    function capPoints() {
      const windowSec = parseInt(rtWindow.value || "3600", 10);
      const maxPoints = Math.max(10, Math.floor(windowSec * 1000 / intervalMs));
      if (pointsSpeed.length > maxPoints) pointsSpeed = pointsSpeed.slice(pointsSpeed.length - maxPoints);
      if (pointsBytes.length > maxPoints) pointsBytes = pointsBytes.slice(pointsBytes.length - maxPoints);
    }

    async function tick() {
      try {
        const ruleID = rtRule.value || "";
        const r = await fetch("/api/stats/now?rule_id=" + encodeURIComponent(ruleID));
        if (!r.ok) return;
        const d = await r.json();
        errorStreak = 0;
        if (emptyBox) emptyBox.style.display = (d.runningJobs || 0) === 0 ? "" : "none";
        pointsSpeed.push({ x: d.ts, y: d.speedTotal || 0 });
        pointsBytes.push({ x: d.ts, y: d.bytesTotal || 0 });
        capPoints();
        canvasFit(speedCanvas);
        canvasFit(bytesCanvas);
        speedChart.draw(pointsSpeed, (v) => humanSpeed(v));
        bytesChart.draw(pointsBytes, (v) => humanBytes(v));
      } catch (e) {
        errorStreak++;
        if (emptyBox && errorStreak >= 3) {
          emptyBox.style.display = "";
          emptyBox.classList.add("alert-warning");
          emptyBox.textContent = "实时采样失败：请检查 /api/stats/now 是否可访问，以及浏览器控制台是否有报错。";
        }
      }
    }

    function reset() {
      pointsSpeed = [];
      pointsBytes = [];
      canvasFit(speedCanvas);
      canvasFit(bytesCanvas);
      speedChart.draw(pointsSpeed, (v) => humanSpeed(v));
      bytesChart.draw(pointsBytes, (v) => humanBytes(v));
    }

    rtRule.addEventListener("change", reset);
    rtWindow.addEventListener("change", reset);
    window.addEventListener("resize", () => {
      canvasFit(speedCanvas);
      canvasFit(bytesCanvas);
      speedChart.draw(pointsSpeed, (v) => humanSpeed(v));
      bytesChart.draw(pointsBytes, (v) => humanBytes(v));
    });
    reset();
    tick();
    setInterval(tick, intervalMs);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initRealtimeCharts);
  } else {
    initRealtimeCharts();
  }
</script>
{{end}}
